<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Search Atlas â€” AI Content Writer Prototype</title>

  <!-- Tailwind CDN (JIT, arbitrary value support) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React + ReactDOM (UMD) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel for in-browser JSX transform (ok for prototypes) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* Small tweak so the body background matches the design immediately */
    html,body,#root { height: 100%; }
    body { background: #0b0f12; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- App code (JSX compiled by Babel) -->
  <script type="text/babel">
    const { useState, useMemo, useEffect } = React;

    /**
     * Lightweight shim that mimics the small subset of framer-motion used in the original prototype.
     * - motion.div / motion.aside apply simple mount animations (translateX/translateY + opacity)
     * - supports whileHover { x?, y? } for hover transform
     * - AnimatePresence is a simple passthrough (no complex exit animation)
     *
     * This keeps behaviour and visuals similar without requiring a build step.
     */
    function makeMotion(tagName) {
      return function MotionComp({ children, whileHover, initial, animate, exit, style, className, ...props }) {
        const [isHovered, setIsHovered] = useState(false);
        const [mounted, setMounted] = useState(false);

        useEffect(() => {
          // trigger "animate" on next frame so CSS transition runs
          requestAnimationFrame(() => setMounted(true));
        }, []);

        // determine transforms from initial / animate / whileHover
        const getTransformFrom = (obj) => {
          if (!obj) return '';
          if (typeof obj.x !== 'undefined') return `translateX(${obj.x}px)`;
          if (typeof obj.y !== 'undefined') return `translateY(${obj.y}px)`;
          return '';
        };

        let transformStyle = '';
        if (!mounted && initial) transformStyle = getTransformFrom(initial);
        else if (mounted && animate) transformStyle = getTransformFrom(animate);

        // override with hover transform if present
        if (isHovered && whileHover) {
          if (typeof whileHover.y !== 'undefined') transformStyle = `translateY(${whileHover.y}px)`;
          else if (typeof whileHover.x !== 'undefined') transformStyle = `translateX(${whileHover.x}px)`;
        }

        const computedOpacity = (!mounted && initial && typeof initial.opacity !== 'undefined')
          ? initial.opacity
          : (mounted && animate && typeof animate.opacity !== 'undefined')
            ? animate.opacity
